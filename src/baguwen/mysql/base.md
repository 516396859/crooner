---
title: MySQL 基础
icon: file
author: Cheney
date: 2024-04-30
isOriginal: true
category: MySQL
order: 1
---


### 1. 数据库三范式了解吗？
- 第一范式：要求属性具有原子性，不可再分
- 第二范式：对记录的唯一性约束，也就是主键约束，要求记录中的非主属性都依赖于主键。
- 第三范式：对字段冗余性的约束，也就是外键约束，任何字段不能由其他字段派生出来。

---

### 2. 为什么不推荐使用外键与级联？
- 增加了复杂性，每次删除与更新都必须考虑到外键。
- 增加了额外工作，数据库需要增加维护外键的工作。
- 对分库分表不友好，分库分表外键无法生效。  

---

### 3. 什么是存储过程？
存储过程看成是一些 SQL 语句的集合，可以类比成代码中的方法，还可以传递参数进行调用。好处是使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。不过由于调试和扩展，没有移植性很少用了。

---

### 4. 数据库设计通常分为哪几步？
- 标准答案：需求分析，概念设计（画E-R图），逻辑设计（E-R图转换为表），物理设计（选择数据库和存储路径），数据库实施（编码、测试、运行、维护）
- 按照自己理解：需求分析，然后画出E-R图，再将E-R图转为表，然后写SQL建表，测试运行维护。

>[!note]
> 两种答案记住一个就行。

---


### 5. SQL语句可以分为哪几类？
- DDL，数据定义语言，对数据库的操作负责数据结构定义与数据库对象的定义；
- DML，数据操纵语言，对数据库具体表的操作；

---

### 6. UNION 和 UNION ALL 的区别？
他们都是将两个或更多查询的结果组合起来，并生成一个结果集。所有查询的列数和列顺序必须相同。通常返回的列名取自第一个查询。但是前者并起来会去重，后者不会去重。

```SQL
select id,name from t1 where age>18 UNION（或者 UNION ALL） select id,name from t2 where age>18 ;
```

---

### 7. 介绍一下索引（INDEX）？
- 加速查找数据库的一个排好序的数据结构，大大加速数据库字段的查找速度；
- 再具体讲下MySQL中索引种类：主键索引、唯一性索引、联合索引、普通索引等等；

---

### 8. MySQL的事务处理知道吗？
MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。对于 delete 和 update 等语句才会事务回滚，对于 select 语句不能回滚。自动提交可以通过 set autocommit=0 可以取消自动提交。

---

### 9. MySQL的触发器知道吗？
触发器是当操作表记录时(增删改)触发的一种操作，可以在增删改之前或者之后触发。例如对某表的删除操作设置触发器，当删除其中一个表中的记录时就将这些记录添加到日志表中。那么以后每删除一行该表的记录都会将记录添加到另外一个表中。

---

### 10. 什么是视图？
视图是一种虚拟表，视图不存储实际数据，而是从基础表中获取数据，提供数据的不同视角。可以对视图进行增删改查等等，但是不影响到真实的表，其他和表的操作一样，主要区别：
- 本身不存储数据，只是查找数据进行展示；
- 不能建立索引，无法使用索引；


### 11. DML 语句和 DDL 语句区别？
- DML数据操作语言，主要对数据库中表记录的增删改查，开发人员经常使用；
- DDL数据定义语言，对数据库内部对象操作的语言—对表进行定义修改删除等，例如表的定义，结构修改；一般数据管理员使用；

---

### 12. MySQL数据库引擎有哪些？
- 主要有 Innodb（MySQL默认的引擎），MyISAM；
- 前后的区别是：行级锁、表级锁；回滚和崩溃恢复能力有和无；支持事务和不支持事务，支持外键和不支持外键；并发能力强和差；自动增长有和无；

--- 


### 13. 说说InnoDB与MyISAM的区别？
现在的MySQL数据库默认使用InnoDB引擎，InnoDB默认使用行锁，锁的粗细度更细，而MyISAM只支持表锁。另外，InnoDB支持数据库崩溃恢复、事务回滚和外键；而MyISAM都不支持，但是MyISAM会保存整个表的行数而InnoDB会执行select count 全表扫描。

---

### 14. SQL优化手段有哪些？
- 查询select 后面跟着字段而不是*号
- 尽可能减少子查询，使用关联查询替代
- where后的字段尽可能是建立索引的字段
- where后面的字段不要进行运算或者函数操作

---


### 15. 简单说一说drop、delete与truncate的区别？
- drop：DDL操作，删除整张表数据和结构
- truncate：DDL操作，删除表全部数据保留表结构
- delete：DML操作，删除一行记录，可以事务回滚；

---

### 16. 并发事务带来哪些问题？
- 脏读：读到了未提交的数据（提交后回滚了的数据）
- 不可重复读：一个事务中前后两次读取同一个数据不一致
- 幻读：一个事务中前后两次读到的记录数量不一致
- 修改丢失：两个事务同时读取某个记录并修改，只有后面的修改才能生效，被覆写

---

### 17. 不可重复读和幻读区别？
 不可重复读是一个事务中前后两次读取到的数据不一致，幻读是前后两次读到的记录数量不一致，可不重复读是因为中途有其他事务进行了修改，而幻读是中途有事务进行了插入或者删除。

---

### 18. 事务隔离级别有哪些？
- 读未提交：会导致脏读；
- 读已提交：不会脏读但是会导致不可重复读、和幻读；
- 可重复读：会导致幻读；
- 可串行化：最高隔离级别，效率很低；

---

### 19. MySQL的默认隔离级别是什么？
InnoDB 存储引擎默认隔离级别是可重复读，但是已经可以完全保证事务的隔离性要求，即达到了 SQL标准的可串行化隔离级别。因为使用的是Next-Key Lock （临键锁）算法，可以避免幻读的产生。
>[!note]
>这里的Next-Key Lock 临键锁在后面会讲到！

---

### 20. 大表如何优化？
- 禁止查询的时候不带任何限制条件
- 读写分离，主库写，从库读
- 分库分表：垂直分区——将表按照业务分库；水平分区———将表按照某个字段的类别进行分库。

### 21. 分库分表之后,id 主键如何处理？
分库分表之后，数据不在同一台数据库服务器上，而是分布式存储在不同的机器上，因此需要使用分布式ID进行重建主键：
- 推特的雪花算法，时间戳+机器码+序列号组成，比较主流的方案，优点是有序唯一性，可以分布式部署。
- redis incr 生成有序 ID，性能好，缺点是容易被猜测到增长规则。

---

### 22. 说说在 MySQL 中一条查询 SQL 是如何执行的？
1. 客户端通过连接器建立连接，包括权限认证
2. 查询缓存，以查询语句为key，不过8.0默认关闭了
3. 分析器：对SQL语句进行词法分析，语法分析
4. 优化器：生成执行计划，选择最优索引
5. 执行器：使用对应的引擎，优化后的SQL，返回结果

---


### 23. 一条SQL语句的执行顺序？
首先我们知道一条SQL语法如下：

```sql
select distinct * from A left join B on xxx where Axx group by xx having xxx order by xx limit；
```

实际上的执行顺序如下：

```
from --> join --> on --> where --> group by --> having --> select --> distinct --> order by -> limit
```
快速记忆：在原SQL语法基础上把 select distinct 插入到having 后面即可。

>[!tip]
>执行原理：首先要知道表是哪个，所以首先是from，这里就包括是否需要连接（join on）操作。紧接着是按照条件选出符号的记录行，也就是where，选出记录行后可能需要根据条件进行分组，也就是 group by --> having。在这些都做完之后，才选择所需要的列 select，这里可能有些记录的列有重复，因此需要 distinct 去重。最后才是排序 order by 和 限制返回数量。

---

### 24. 什么是临时表，何时删除临时表？
临时表是执行SQL语句的过程中产生的临时存储一些中间结果的表，只对当前连接可见，当断开连接时自动释放所有临时表空间。在进行子查询的时候会建立临时表，频繁建立销毁临时表非常消耗资源，因此使用子查询效率很低。

---


### 25. MySQL的常用索引有哪些？
B+ 树和哈希索引（详细请参考MySQL索引篇）

---

### 26. MySQL 中 varchar 与 char 的区别？varchar(30) 中的 30代表的涵义？
- char是固定长度，多出的部分使用空格填充；varchar是可变长度存储实际的长度；
- char最多存储255个字符数，varchar可以存储6万多个字符；
- 在查询效率方面，因为char是固定长度不需要额外的长度检查，因此比varchar要快很多。

---


### 27. 为什么 SELECT COUNT(*) FROM table 在 InnoDB 比MyISAM 慢？
因为在MyISAM引擎中内部维护一个计数器统计表的记录数，而InnoDB每次都需要全表扫描计数。

---

### 28. count(1)、count(*)和count(列名)的区别？
- 在MySQL中，count(1) 和 count(`*`) 都可以用来统计行数。它们的区别在于，count(1) 是基于1这个常量进行统计，而count(`*`) 则是统计所有行。但是，这两种方式的性能是相同的，因为在执行时，MySQL 会对所有行进行遍历，而无论是基于1还是 `*`，每行都会被统计一次。
- count(列名) 是基于某一列进行统计的方式。在进行统计时，MySQL 会跳过该列为 NULL 的行，因此它的统计结果可能会小于表中的总行数。因此，当统计某一列非 NULL 值的数量时，可以使用 count(列名)。
- 当列名是主键时，count(列名) 和 count(`*`) 的性能是相同的，因为主键列不允许出现 NULL 值。但是，当列名不是主键时，使用 count(`*`) 会比 count(列名) 更快，因为 MySQL 不需要检查该列是否为 NULL。

---

### 29. 为什么禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询？
- * 选择所有的列，即使不需要的列也选择，会消耗更多的IO和网络带宽资源
- 无法使用覆盖索引，也许 select 列1，列2 达到了覆盖索引，但是如果是*就无法覆盖到
- 使用字段可以减少表结构带来的影响，如果使用 select 列1，列2，就算表增加了一列也不影响

---

### 30. 子查询性能差的原因？
子查询无法使用索引，子查询会创建临时表，临时表不存在索引；临时表创建与销毁会消耗过多的资源导致大量慢查询。



### 31. 说说什么是 MVCC ？
多版本的意思就是数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。（更加详细的介绍请参考 难点终结篇章第一问！）

---

### 32. MVCC 可以为数据库解决什么问题？
- MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读
- 我们都知道并发访问数据库造成的四种问题（脏写（修改丢失）、脏读、不可重复读、幻读），MVCC就是在尽量减少锁使用的情况下高效避免前三个问题，最后幻读是通过加临键锁解决的。

---


### 33. 请说说 MySQL 数据库的锁？
- 共享锁：读锁，允许多个用户同时读取数据；share model
- 互斥锁：写锁，一个资源被写锁操作时不运行其他操作进行。for update
- 表锁：MyISAM使用表锁，开销小但并发低；
- 行锁：InnoDB默认行锁，行锁必须依赖与索引，高并发度；

---

### 34. 说说什么是锁升级？
- 数据库中的锁升级指的是：InnoDB中行锁是加在索引上的，如果不走索引的话就会升级为表锁。原因是InnoDB是将主键和相关的索引放在B+树的叶子节点上。
- 当非唯一索引中某索引字段的内容如果相同的大于整个表的1/2则升级为表锁，此时走索引比全文检索还慢，因此在优化器中不会走索引，因此就是使用表锁；

---


### 35. 主键与索引有什么区别？
- 主键可以作为索引，但索引不能作为主键
- 主键不能为null且唯一，唯一性索引可以为空
- 主键只能有一个，但索引可以有多个
- 主键是一种约束，索引是一种查询数据的数据结构

---

### 36. 自增主键一定是连续的吗？
不一定，自增主键的值放在了redo log中，提供了持久化的能力；但是如果强行跳跃插入id值也会导致id值跳跃；如果出现了回滚，那么自增主键为了提高性能不会回滚。

---


### 37. MySQL 存储引擎架构了解吗？ 
MySQL采用的是插件式架构，支持多种存储引擎；存储引擎是基于表的而不是数据库的，甚至可以为不同的表设置不同的存储引擎以适应不同的场景需要 ，并且还可以更具提供的存储引擎接口编写属于自己的存储引擎。

---
 