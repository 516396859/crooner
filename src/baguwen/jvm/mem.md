---
title: 内存结构
icon: file
author: Cheney
date: 2024-05-06
isOriginal: true
category: JVM
order: 1
---

### 1. 简述JVM基本内存结构？
**堆内存**（对象，串池，静态变量）、**虚拟机栈**（栈帧、方法的参数、返回地址、局部变量）、**程序计数器**（指向字节码运行的行号|位置）、**本地方法栈**（native方法的栈）、**方法区**（元空间、类结构、常量池、运行时常量池、JIT编译过的机器码）

---

### 2. 哪些内存结构线程共享？
堆内存、方法区、直接内存

---

### 3. 哪些内存结构设计垃圾回收？
堆内存、方法区的永久代如果空间不足则触发Full GC（JDK1.8及之后的元空间不会发生垃圾回收）

>[note]
> 在早期的版本中JDK1.8之前，方法区中的是永久代，它使用的是JVM内存，只有full GC才进行垃圾回收。而JDK1.8摒弃了永久代，因为永久代使用JVM内存，这样就很难设置永久代的内存大小，因为它不会进行一般的young GC垃圾回收。因此，使用了元空间来解决此问题，元空间使用操作系统的本地内存，好处就只不需要指定大小，默认是无限的空间大小。

---

### 4. 哪些内存内存结构发生内存溢出？
除了程序计数器之外都会内存溢出；
- 堆内存：对象太大或者太多；
- 虚拟机栈：方法递归太深、局部变量太多太大；
- 方法区：加载了太多第三方jar包、常量池过大；
- 直接内存：物理内存不足；

---

### 5. 垃圾回收是否涉及栈内存？
不涉及、栈会自动出栈释放内存；

---

### 6. 栈内存分配越大越好吗？
栈内存越大，栈帧（存放方法的数据）越多，能够更深递归，但是能够创建的线程数量会变少。

---

### 7. 方法内的局部变量是否线程安全？
一般局部变量在栈帧中，线程私有，线程安全；但是逃离了方法的作用范围非线程安全，例如通过参数传递逃离的引用变量。引用变量对象很可能存放在堆内存上，这是共享作用域，逃离了作用范围。

---

### 8. 聊聊堆内存？
堆内存分为年轻代和老年代，年轻代存放朝生暮死频繁生命周期短的对象，因此垃圾回收时大多数对象需要回收，适合复制算法进行垃圾回收。其中，年轻代分为伊甸区和幸存区；老年代空间比较大，一般占堆内存2/3，存放生命周期长的对象。一个对象创建时先存入伊甸区，当伊甸区内存不足时进行Minor GC，伊甸区和From区的幸存对象复制到To区，生命加1，达到15进入老年区。当老年代空间不足时先触发Minor GC再触发Full GC。

---

### 9. 堆内存诊断工具知道吗？
可以使用命令 jmap -head 12883 查看12883进程堆内存占用情况。另外一些可视化的工具例如Java自带的 VisualVM 。

---

### 10. 变量存放在哪里？
局部变量存放在栈中，成员变量存放在堆中，静态变量存放在方法区中，如果以上变量是引用，则对应的对象都存放在堆中。

---

### 11. 虚拟机栈和本地方法栈为什么是私有的？
保证局部变量作用域只在本线程中，不被别的线程访问。


 