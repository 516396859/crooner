---
title: 类加载机制
icon: file
author: Cheney
date: 2024-05-06
isOriginal: true
category: JVM
order: 2
---


### 1. 类加载的详细过程了解吗？
- 加载：每个类都有加载它的ClassLoader，将class文件加载到内存中，将静态数据结构加载到运行时常量池中，在堆中生成代表这个类的class对象。
- 连接：包括验证、准备、解析三步骤；
    1. 验证：验证class文件的规范性，保证虚拟机自身安全；
    2. 准备：为static类变量在方法区中分配内存并设置初始值。
    3. 解析：将方法区中常量池中的符号引用替换为直接引用。
- 初始化：执行类中定义执行类构造器方法的过程 ，创建实例对象时进行。
- 使用：调用对象的方法或者类的静态方法；
- 卸载：Class对象被GC，在没有任何地方被引用、类加载器被GC、没有任何对象时卸载。

---

### 2. 类加载器原理懂吗？
类加载器的主要作用是将class字节码文件加载到JVM中，类加载器并不会一次性加载所有的类，而是根据需要去动态加载。JVM内置了三大类加载器：启动类加载器：最顶层的加载器加载java的核心类库（jre核心类库）、扩展类加载器：加载java的扩展库ext下的jar包、程序类加载器：负责加载当前应用路径下的所有jar包和类；最后加载类通过双亲委派机制加载的。

---

### 3. 双亲委派机制知道吗？
双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。即加载任意一个类都要 加载器唯一、这个类唯一。而加载器根据类的全限定类名来加载到JVM内存中再转为类对象。在类加载的时候，首先不会自己去加载类而是把这个加载请求委派给父类去加载，如果父类加载了直接返回，如果没加载则也递归向上级父类委派；只有当父类加载器没找到所需的类也就是加载不了，子类才尝试自己加载；总结：自底向上委派加载，自顶向下尝试加载；如果都没找到该类则抛出ClassNotFound异常；保证了任意一个类只能被加载一次，且加载器是唯一的。

---


### 4. 为什么需要双亲委派模型？
如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？防止内存中出现多份同样的字节码。

---

### 5. 怎么打破双亲委派模型？
打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass()和findClass()方法。 即原来的loadClass()默认向父类加载，这里可以调用findClass()自己加载。

---

### 6. Java类的初始化知道吗？
类的初始化也是延迟的，直到类第一次被主动使用，JVM 才会初始化类。 初始化过程的主要操作是执行静态代码块和初始化静态域(静态变量，常量池加载到运行时常量池)。在一个类被初始化之前，它的直接父类也需要被初始化。

---

### 7. 加载到内存中的 class 数量太多或者体积太大怎么办？
增加 Metaspace 的大小 ： `-XX:MaxMetaspaceSize=512m`

---

### 8. JVM 组成结构清楚吗？
包括两个子系统和两个组件：类加载和执行引擎、运行时内存结构和本地接口；

- 类加载：根据给定的类全限定名加载class文件到方法区中，然后在堆上创建一个 java.lang.Class对象
- 执行引擎：执行class中的指令；
- 本地接口：调用native 方法也就是底层封装的方法的接口；
- 运行时内存结构：常说的JVM内存结构；

整个过程就是，.java文件首先被编译成.class文件，然后被类加载器加载到方法区中。.class文件并不能直接被底层操作系统执行，所以需要解释器进行解释成机器指令，再交给操作系统CPU去执行。其中有些底层实现调用了native本地方法，C语言实现的。

---

### 9. 字符串常量池知道吗？
字符串常量池原来放在方法区，由于不好垃圾回收于是后来jdk8是存放在堆上的，字符串常量池存储的是string对象的直接引用，而不是直接存放的对象，是一张string table。String 对象还是放在堆内存上，只是调用intern()方法之后，会在string table中指定其引用。

---



### 10. 常量池与运行时常量池的区别是什么？
常量池和运行时常量池都是Class的一部分，都在方法区，随着类加载而加载；常量池用于存放编译期生成的各种字面量与符号引用。加载完后就放在运行时常量池中。

---

### 11. 堆外内存与堆内存有什么不同？
堆外内存, 常常又叫做直接内存。 把内存对象分配在Java虚拟机的堆以外的内存， 直接受操作系统管理（而不是虚拟机），能够在一定程度上减少垃圾回收对应用程序造成的影响。 我们经常用`java.nio.DirectByteBuffer`对象进行堆外内存的管理和使用，它会在对象创建的时候就分配堆外内存。

---

### 12. 为什么用元空间替代永久代？
- 永久代的空间难以确定，永久代占用的是JVM内存，难以调优。
- 元空间占用的是本地内存，无需进行调优。

---
 

### 13. 为什么字符串常量池放在堆中？
因为永久代中需要进行Full GC才能垃圾回收，导致字符串常量池回收效率不高，放在堆上可以提高回收效率。

---

### 14. 使用堆外内存的优点？
- 减少了垃圾回收
- 加快了复制的速度

---

### 15. 对象创建的流程？
- 判断类是否加载，没有加载则先加载类
- 类加载后，接下来分配内存。判断堆内存是否规整（连续）和垃圾回收算法有关，分为指针碰撞（规整的内存分配算法：指针左边的是已经分配的内存，右边是未分配内存）和空闲列表（零碎内存分配算法：维护一个内存记录表，记录已分配的内存地址，从未分配的内存中找一块足够大的内存分配）。
- 并发CAS分配内存，因为高并发创建对象时，可能多个进程判断某个内存是空闲的，于是都去占用创建对象。
- 将分配到的内存都初始化为0值，并将引用指向新的对象空间。

---


