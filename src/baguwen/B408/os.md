---
title: 操作系统
icon: file
author: Cheney
date: 2024-05-06
isOriginal: true
category: Java
order: 4
---
 

### 1. 用户态和内核态
为了系统的稳定性与安全性，进程地址空间分为用户态和内核态：
- 用户态：用户进程只能读取或修改程序的数据，拥有的权限较低；
- 内核态：拥有非常高的权限，几乎可以直接访问操作系统的任何资源，包括内存空间、设备驱动程序等等；
当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。


---

### 2. 为什么要有用户态和内核态？只有一个内核态不行么？
- CPU的所有指令中，特权指令（内存分配、IO处理）是比较危险的，，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，特权指令只能由系统内核态执行；
- 如果计算机系统中只有一个内核态，调用底层的内存或者CPU或者硬盘时，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。


---

### 3. 用户态和内核态是如何切换的？
用户态切换到内核态的3中方式：
- 系统调用：用户态进程主动要求切换到内核态的一种方式，当需要调用系统资源时，例如读取磁盘资源，分配内存资源，需要系统调用；
- 中断：当发起系统调用时，如果当前执行在用户态下则CPU会中断执行下面的代码而是跳转去执行中断处理程序，也就是内核程序。当执行完内核程序时有会发生中断，从内核态切换回用户态继续执行下面的代码。
- 异常：CPU在用户态程序执行时，当发生了某些异常例如缺页中断会导致切换到内核态；

---

### 4. 哪些操作属于系统调用？
当用户态需要使用到操作系统的内核态资源时需要使用特权指令，例如文件管理、进程控制、内存管理、设备管理需要进行系统调用。


---



### 5. PCB是什么？
PCB是进程控制块，每个进程都有一个PCB，PCB主要包括：
- 进程的描述信息：进程名称、标识符
- 进程的调度状态：阻塞、运行、优先级
- 进程对资源的需求：CPU时间、内存空间


---

### 6. 线程的同步方式有哪些？
互斥锁（ReenterLock、synchronized）、读写锁（WriteReaderLock）、信号量（Semaphore）、屏障（CyclicBarrier）、通知（notify、wait）


---

### 7. 进程间的通信方式？
- 信号：notify，wait
- 信号量：semaphores，信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。
- 共享内存：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。


---

### 8. 进程的调度算法
- 先到先服务：就绪队列中选择最先进入队列的进程为之分配资源
- 时间片轮转：将CPU的使用权按照时间分片，最公平使用最广的算法。
- 优先级调度：优先级高的进程先分配资源运行。
- 短作业优先：选择估计运行时间最少得进程分配资源运行


---



### 9. 什么是僵尸进程和孤儿进程？
在Linux系统中，子进程都是调用foke()创建的，因此也会创建一个子进程的PCB块，子进程和父进程运行是独立的，父进程结束了子进程依旧可以运行。子进程的PCB回收只有父进程调用wait()才能释放，但是如果父进程调用exit()退出了（释放所有资源）就无法回收子进程的PCB。查看僵尸进程的命令：zombie
- 僵尸进程：子进程已经结束了，PCB还在，但是父进程没有调用wait()释放子进程占用资源PCB依旧存在。这种情况子进程被称为僵尸进程，不运行了但是资源还在。
- 孤儿进程：子进程的父进程已经不存在了（往往由于意外终止导致未及时回收子进程），但是子进程还在运行，为了避免占用系统资源，操作系统统一使用init进程回收孤儿进程资源。


---

### 10. 什么是死锁？
在多线程下，多个线程同时相互等待对方释放资源而自己不释放资源的状态称为死锁。死锁如果不介入的话会无限期阻塞。四个产生死锁必要条件：资源互斥、循环等待、占有并等待、不可剥夺。


---




### 11. 解决死锁的办法？（注意不同于另外一个问题——避免死锁的办法？）
- 预防死锁：破坏死锁四个必要条件之一，资源互斥往往无法破坏，破坏不可剥夺——采用优先级调度算法、抢占式调度，资源利用率低；破坏占有并等待——执行之前必须申请到所有需要的全部资源；破坏循环等待——申请B资源必须要持有A资源才可以层次申请资源；每个破坏都会导致系统资源利用率降低；
- 避免死锁：银行家算法，当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过 安全性算法 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 真的分配资源给该进程。
- 解除死锁：立即结束所有进程；撤销死锁的进程；从某几个进程中抢占资源；


---