---
title: 多线程与线程池
icon: file
author: Cheney
date: 2024-04-29
isOriginal: true
category: Java
order: 3
---



### 1. 多线程的安全性问题了解吗？
线程安全指的是：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的，或者说共享数据块每一时刻都只能有一个线程操作。

程序存在线程安全问题的条件：

- 是否是多线程（单线程没有线程安全问题，例如 Redis）
- 是否共享数据 (数据不共享一般不会有安全性问题，例如 ThreadLocal)
- 是否多个条语句操作共享数据 (主要指的是多线程环境下的写操作，读操作没有安全性问题)

保证多线程安全的方法：只需要将共享数据的代码锁起来，让任意时刻只有一个线程在执行即可。造成多线程安全问题的真正原因：并发环境下CPU上下文切换导致指令的交错执行，操作同一数据。也就是上述三个条件。

---

### 2. 如何停止一个正在运行的线程？
- 使用退出标志 flag，当不满足运行条件，程序 return 结束
- 使用 stop 方法强行终止
- 使用 interrupt 方法中断线程，通过判断中断标志来结束线程
> [!important]
> 每种方法的背后需要知道，上面简述只是回答面试官的答案，你需要根据上面的提示说出背后的原理！切记，Crooner Note不是减轻你的背诵，而是通过简单的答案唤醒你的知识记忆！

---

### 3. sleep()和wait() 有什么区别？
sleep 方法属于 Thread 类，wait 方法属于 Object 类。当调用 wait() 方法的时候，线程会放弃对象锁，进入此对象的等待队列中挂起 。只有针对此对象调用 notify() 方法后本线程才进入对象同步队列竞争锁对象。

- sleep() 方法没有释放锁，而 wait() 方法释放了锁 。
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法必须设置时间参数，时间到线程会自动苏醒，前者也可以设置超时时间 wait(long timeout) 超时后线程会自动苏醒。
- sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。

---

### 4. 为什么 wait() 方法不定义在 Thread 中？
wait 方法是 Object 的方法，每个对象都有，是让自己释放当前的对象锁并挂起，对象锁是在对象头的 MarkWord 中，重量级锁对象是通过监视器对象实现的，因此当调用 wait 方法就会将当前线程挂起并加入到当前监视器的等待队列中。以上说明与 wait 打交道的都是对象，因此 wait 方法释放锁是操作对象而不是 Tread 类。为什么 sleep() 方法定义在 Thread 中？因为 sleep() 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

---

### 5. 为什么wait, notify 和 notifyAll这些方法不在thread类里面？
JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。上面的答案符合本题！

---

### 6. 为什么wait和notify方法要在同步块中调用？
只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的 wait(),notify()和notifyAll()方法。wait() 方法强制当前线程释放对象锁。这意味着在调用某对象的 wait() 方法之前，当前线程必须已经获得该对象的锁。在调用对象的notify() 和 notifyAll() 方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的 notify() 或 notifyAll() 方法。

---


### 7. 线程和进程的区别？
- 进程是系统资源调配的最小单位，线程是操作系统执行的最小单元；
- 一个进程包含多个线程，多个线程共享同属进程的资源。
- 进程是程序的一次执行过程。一般一次用户请求是一个线程。
- 线程的切换速度比进程快多了。

---

### 8. 并行和并发的区别？
并行是多核真正的同时执行，并发是单核上下文切换串行执行。在多核操作系统中既有并行也有并发，因为进程和线程数大于 CPU 内核数。

---

### 9. 同步和异步的区别？
- 同步：往往伴随阻塞和等待，即当一个任务调用另外一个任务时，需要阻塞式等待另一个任务运行完毕返回结果就是同步；
- 异步：如果不需要等待结果立即返回的是异步；异步效率更高，例如 redis 中 keys 是同步命令，scans 是异步命令。
>[!important]
>同步，异步这种概念要非常清楚。IO 有同步异步，异步效率往往比同步更高；锁一定是同步锁；线程有同步和异步，同步通过锁实现，异步通过 FutureTask 类等实现；同步一般和阻塞、串行、等待相关。

---

### 10. 什么是线程同步？
在多线程并发时，线程同步是保证多个线程之间执行的一致性和正确性，采用同步的机制使得多个线程并发执行就像单线程一样不会发生线程安全问题，达到类似同步串行执行的效果，通常使用互斥锁、乐观锁、join 等机制保证线程同步。保证数据一致性和安全性。

---

### 11. 线程创建的四种方式？
- 继承Thread重写run方法，缺点需要继承
- 实现Runnable重写run方法，target作为Thread参数执行，多实现
- 实现Callable重写call方法，作为FutureTask的参数，再作为Thread的参数；异步执行，当启动线程后，可以通过FutureTask对象get方法获得执行结果或者异常信息。
- 线程池技术

---

### 12. Thread中start() 和 run() 方法的区别？
run()当前线程作为普通方法执行一次，只有start才会开启新的线程去执行 run 方法。

---

### 13. 关于线程操作的常用方法？
start、yield、join、wait、notify、setDaemon(true)

---

### 14. 聊聊中断方法interrupt？
interrupt 不会像 stop 暴力终止线程，而是将中断标志位设置为 true，线程执行不会被直接打断而是需要开发者自己编写代码判断 interrupt 标志位来终止线程。当处于 sleep、wait、join 阻塞状态时，会打断阻塞立即抛出一个中断异常，在异常中可以选择重新设置标志位继续执行或者结束执行。如果不在阻塞状态则会中断线程执行，需要自己释放资源避免死锁。

---

### 15. interrupted() 和 isInterrupted() 的区别？
都是判断线程是中断标记的，带 is 的调用该方法后不会清除打断标记（当为 true 时调用该方法后重置为 false ），不带 is 的会重新清除打断标记重置为 false。

---

### 16. 线程优雅终止——两阶段终止模式知道吗？
在一个线程 T1 中如何优雅终止线程 T2？ 两阶段指的是线程T2运行阶段和T2阻塞阶段，T1中通过 interrupt 打断T2在运行阶段没问题，可以在T2中判断打断标志从而释放资源，return 终止线程。对于阻塞阶段，打断会抛出打断异常（捕获即可进入运行阶段），我们捕获打断异常中通过调用 thread.interrupt() 重设打断标记，再次打断现在处于运行阶段的T2来达到打断T2的目的。
>[!tip]
>记住运行阶段和阻塞阶段两个阶段的不同处理方式即可！

---


### 17. Daemon守护线程？
GC线程就是守护线程，也叫后台线程，当所有的前台线程都被销毁了，守护线程才能结束。没有了前台线程，守护线程才销毁，否则一直后台执行。

---

### 18. 线程（原理）运行机制知道吗？
每个线程启动后，虚拟机就为其分配一块栈内存，存放栈帧；程序计数器记住下一条字节码的执行地址，存放在方法栈中。当发生上下文切换的时候，需要保存当前线程状态信息到程序控制块中，并恢复另外一个线程。线程的调度是在内核态运行的，而线程中的代码是在用户态运行的。所以线程切换会导致用户态和内核态进行系统调用。(结合JVM理解！)

---

### 19. 线程调度方式？
- 分时调度模型，让所有线程轮流获得 CPU 的执行权，轮询执行，平均占用时间片。
- 抢占式调度，让优先级更高的线程占用 CPU，同一优先级随机挑，高优先级只是高概率！可能导致低优先级的线程饥饿。

---

### 20. Java中线程状态？
从操作系统来讲有五种状态：新建状态、就绪状态、运行态、阻塞态、终止态；
从JVM讲：新建态、运行态（包括了就绪态）、限时等待状态（sleep(2000)，wait(2000)，join(2000) ），等待状态（wait，join，park），阻塞态（同步队列），终止态。

>[!important]
>可以理解为JVM的各种等待状态和阻塞状态等价于操作系统的阻塞状态，然后JVM的运行态包括了就绪态。最后一定要搞清楚什么是等待队列什么是同步队列！下一题就讲这个！

---

### 21. 同步队列和等待队列的区别？
- 等待队列（需要唤醒的线程，对应的是等待和限时等状态）：存放的是等待唤醒的线程（调用wait、join后的状态是等待状态），notify唤醒后进入同步队列。
- 同步队列（需要抢锁的线程，对应的是阻塞状态）：唤醒后的线程并不是立即可以执行，而是需要去抢占同步方法对象的锁，需要进入对象锁的同步队列中排队。

---

### 22. 你是如何解决生产者和消费者问题？
最佳方式：使用Semaphore信号量控制并发或者使用BlackingQueue来实现生产者消费者模式；

---

### 23. Java线程池中submit() 和 execute()方法有什么区别？
- execute() 的参数只能是 Runnable 对象，submit() 方法参数可以是 Runnable 对象和 Callable()对象，因此决定了返回值的不一样。e
- 两个方法都可以向线程池提交任务，execute() 方法的返回类型是 void，而 submit()方法可以返回持有计算结果的Future 对象，而可以从 Future 对象的 get() 方法获取结果或者异常信息；
- submit() 方法可以提交 Runnable 类型的参数，但执行 Future 方法的get()时，线程执行完会返回 null，不会有实际的返回值，这是因为 Runable 本来就没有返回值

---

### 24. 什么是阻塞式方法？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情；例如 Semaphore 的 acquire() 是阻塞方法；

---

### 25. 什么是线程安全，保证线程安全的方法有哪些？
线程安全就是在多线程并发访问的环境下保证数据的一致性与可靠性，就像单线程一样不出差错。保证线程安全的方法：加锁、使用JUC同步类、使用 ThreadLocal 、乐观锁。

---

### 26. Java中Semaphore是什么？
信号量同步机制，可以限制同时访问某个资源的并发线程数量，acquire() 方法获取锁，或者通过 release() 方法释放锁。当超过最大并发数则陷入阻塞直到别的线程释放；底层是 Semaphore 维护了一个计数器，该计数器表示可用的许可数量。new Semaphore(n) 表示共享锁最多可以被n个线程同时持有！

---


### 27. 在多线程中，什么是上下文切换(context-switching)？
上下文切换指的是CPU执行不同线程的代码的切换，涉及到用户态和内核态的切换过程，开销很大。在时间片或者阻塞时会发生上下文切换；

---

### 28. 多线程中的忙循环是什么？
忙循环指的是一个空循环，用来避免上下文切换，适合短暂的阻塞，例如轻量级锁；不适合大量线程争夺锁的情况下（只有一个线程获取锁），会引起CPU压力暴增，效率低下；

---

### 29. volatile 变量和 atomic 变量有什么不同？
volatile 变量保证变量的线程可见性和避免指令重排；atomic 变量是原子变量，用来保证变量的原子性，例如 a++ 不是原子操作，但是而 AtomicInteger 是原子操作；

---

### 30. 如何在Java中创建线程安全的Singleton？
- 饿汉模式，采用静态常量创建单例对象；
- 懒汉模式的 DCL 模式，注意使用 volatile 修饰单例对象；
- 使用枚举类实现单例模式，在类加载时就确定了枚举类的值。


### 31. Java中什么是竞态条件？
多线程并发执行时执行结果依赖于线程执行的顺序，结果不唯一的情况成为竞态条件；多个线程修改一个共享变量时发生；避免竞态条件发生：锁、JUC并发类；

---

### 32. 什么是FutureTask？
FutureTask表示一个异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对Callable和Runnable的对象进行包装，但是Runnable对象没有返回结果，因此执行完Runnable后FutureTask包装返回null值；

---

### 33. Callable和Future 的关系？
Callable开启线程是并行的，我们必须等待它返回结果。而使用Future，线程池提交Callable任务后返回了一个Future对象，我们可以通过future对象得知任务状态和执行结果，get阻塞式获取结果。

---

### 34. Java中同步集合和并发集合的区别？
它们都是为多线程提供线程安全的集合，差别是性能方面的；同步集合一般使用synchronized 等加锁机制实现，而JUC中的很多方法都进行了极限优化，优化方法不限于分段锁、乐观锁、AQS等机制；并且提供了更强大的原子类，性能更好；一般情况下优先使用并发集合；

---

### 35. Java中如何获取线程的堆栈信息？
使用jstack查看线程和栈的信息

---

### 36. 如果同步块内的线程抛出异常会发生什么？
当前线程终止执行，无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我们更喜欢同步块，因为它不用花费精力去释放锁，ReentrantLock可以在finally block里释放锁。

---

### 37. 一个线程运行时发生异常会怎么样？
如果没有被捕获则线程停止执行，状态为终止状态；如果不在同步块中则无法及时释放占有的资源；如果捕获了就按照开发者的处理逻辑选择结束或者继续运行下去。

---

### 38. 给出3条你遵循的多线程最佳实践？
- 给线程取有意义的名字更好追踪；
- 缩小同步块；
- JUC替代同步集合；

---

### 39. 什么是Java线程转储(Thread Dump)，如何得到它？
线程转储是一个JVM活动线程的列表 ，可以使用jstack工具获得； 也可以通过VisualVM等工具获得

---

### 40. 什么是并发容器？
并发容器是针对多个线程并发访问设计的，JUC包中提供了很多并发容器，如 ConcurrentHashMap，CopyOnWriteArrayList 等。并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map 。并发容器比同步容器性能更加好。

---


### 41. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？
原子操作是指在多线程环境下避免竞态条件的实现。JUC提供了很多原子类，如AtomicInteger； AtomicLong； AtomicReference； AtomicBoolean；还有分段锁的LongAdder。

---

### 42. JVM有哪些不同的线程生命周期|线程状态？
- 初始状态：新建线程对象，start方法之前
- 运行状态：start后，包括就绪态和运行态
- 限时等待：sleep、join、wait方法的超时参数
- 等待状态：调用wait、join方法
- 阻塞状态（同步状态）：排队竞争锁，等待状态调用notify后进入同步状态
- 终止状态：执行完毕或者异常抛出

---

### 43. 线程之间是如何通信的？
Object类中wait() notify() notifyAll()方法可以用于线程间通信关于资源的锁的状态。ReentrantLock 中是await()、signal()等；

---

### 44. 为什么Thread类的sleep()和yield()方法是静态的？
sleep，yield不涉及到对象锁，只是让线程休眠肯定是要在执行的线程上运行；而wait和notify是和锁对象相关的，他们的调用都要修改对象头的锁标识，因此是属于Object的。

---

### 45. 什么是线程池？
是指管理一组工作线程的资源池，当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。线程池有下列好处：

- 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
- 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 。

---

### 46. 如何创建线程池？
- 通过Executors工厂类创建，可以创建newSingleThreadExecuto只有一条线程的线程池；也可以通过newFixedThreadPool 创建固定数量的线程池；newCachedThreadPool 创建可缓存线程池，核心线程数是 0， 最大线程数是2^29，全部都是救急线程（60s 后可以回收），可能会创建大量线程，从而导致 OOM。
- 使用标准构造器ThreadPoolExecutor创建线程池，这是大厂推荐的做法，避免上面的阻塞队列爆满无限制放入阻塞的任务导致OOM。
:::details
- newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
- newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
- newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
:::

---

### 47. 线程池的调度流程？
当提交一个新任务到线程池时，具体的执行流程如下：
1. 当我们提交任务，线程池会根据核心线程数(corePoolSize)大小创建若干任务数量线程执行任务
2. 当任务的数量超过corePoolSize数量，后续的任务将会进入任务阻塞队列阻塞排队
3. 当阻塞队列也满了之后，那么将会继续创建(最大线程数maximumPoolSize-corePoolSize)个数量的线程来执行任务，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程等待活跃时间keepAliveTime之后被自动销毁
4. 如果达到maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理

---

### 48. 如何确定核心线程数量？
- IO密集型：由于IO密集型任务的CPU使用率较低，导致线程空余时间很多，因此通常需要开CPU核心数两倍的线程。
- CPU密集型：CPU密集型任务虽然也可以并行完成，但是并行的任务越多，花在任务切换的时间就越多， CPU执行任务的效率就越低，所以要最高效地利用CPU， CPU密集型任务并行执行的数量应当等于CPU的核心数。
- 混合型任务：混合型任务既要执行逻辑计算，又要进行大量非CPU耗时操作，业界有一个比较成熟的估算公式，具体如下：最佳线程数目 =（线程等待时间与线程CPU时间之比 + 1） * CPU核数
>[!note]
>IO密集型是两倍主要是不吃CPU运行频繁上下文切换，CPU密集型不允许CPU上下文切换增加CPU的压力。

---

### 49. 线程的提交方法？
- submit() 方法提交任务有返回值，execute()无返回值；
- 接受的参数不一样，execute()方法只能接收Runnable类型的参数，而submit()方法可以接收Callable、 Runnable两种类型的参数。 Callable类型的任务是可以返回执行结果的，而Runnable类型的任务不可以返回执行结果。
- submit()方法自身并不会传递结果，而是返回一个Future异步执行实例，处理过程的结果被包装到Future实例中，调用者可以通过Future.get()方法获取异步执行的结果。

---

### 50. 线程池的关闭方法？
优雅地关闭线程池主要涉及的方法有3种：

- shutdown：是JUC提供一个有序关闭线程池的方法，此方法会等待当前工作队列中的剩余任务全部执行完成之后才会执行关闭，但是此方法被调用之后线程池的状态转变为SHUTDOWN，线程池不会再接收新的任务。
- shutdownNow：是JUC提供一个立即关闭线程池的方法，此方法会打断正在执行的工作线程，并且会清空当前工作队列中的剩余任务，返回的是尚未执行的任务。
- awaitTermination：等待线程池完成关闭。在调用线程池的shutdown()与shutdownNow()方法时，当前线程会立即返回，不会一直等待直到线程池完成关闭。如果需要等到线程池关闭完成，可以调用awaitTermination()方法。

---


### 51. 线程阻塞队列（工作队列）？
- ArrayBlockingQueue 是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
- LinkedBlockingQueue 一个基于链表结构的无界阻塞队列，此队列按FIFO （先进先出） 排序元素，新任务可以被无限制地缓存到该阻塞队列中，直到资源耗尽。
- PriorityBlockingQueue 一个具有优先级的无限阻塞队列。 PriorityBlockingQueue 也是基于最小二叉堆实现。
- SynchronousQueue 一个不存储元素的阻塞队列，每一个生产线程会阻塞到有一个 put 的线程放入元素为止。每次put时必须被get，否则一直阻塞。
- DelayQueue 只有当其指定的延迟时间到了，才能够从队列中获取到该元素； DelayQueue 是一个没有大小限制的队列； 因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。

---

### 52. 线程池的拒绝策略？
四种拒绝策略：
- AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
- CallerRunsPolicy：只用调用者所在的线程来处理任务
- DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
- DiscardPolicy：直接丢弃任务，也不抛出异常

---

### 53. 为什么不建议使用 Executors静态工厂构建线程池？
大厂的编程规范都不允许使用Executors创建线程池，可能阻塞队列中会堆积大量的任务或者创建大量的线程，从而导致OOM。而是要求使用标准构造器ThreadPoolExecutor创建线程池。自定确定线程的核心数量和最大数量。

---

### 54. 线程池常用参数？
核心参数：
- corePoolSize : 任务队列未达到队列容量时，最大可以同时运行的线程数量。
- maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- workQueue: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
- ThreadPoolExecutor其他常见参数 :
- keepAliveTime:线程池中的线程数量大于 corePoolSize 的为救急线程，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；
- threadFactory :executor 创建新线程的时候会用到。
- handler :饱和拒绝策略。

---

### 55. 什么是ThreadLocal变量？
每个线程都有一个私有的ThreadLocal，意味着其中的变量不存在共享，彻底避免竞争条件。原理是Thread中有一个ThreadLocalMap内部类，而key为ThreadLocal，value为存储的值。可以比作Thread为人，ThreadLocalMap为书包，ThreadLocal为书包中的一页纸。

---

### 56. ThreadLocal用在什么地方？
保存线程的上下文信息，例如在拦截器中可以将用户信息存储在 ThreadLocal 中。如果同步带来的性能损失无法解决业务的情况下可以考虑 ThreadLocal。

---

### 57. ThreadLocal存在的问题？
ThreadLocal 是线程隔离的，无法解决共享对象的更新问题，且占用栈内存。

---

### 58. 为什么要调用remove方法进行清理？
在 ThreadLocalMap 中，key 是弱引用，可以被垃圾回收；但是 value 是被 entry 强引用所指向的，无法简单被GC，在使用 ThreadLocal 时，使用完毕后，配合调用 remove()，就会清除掉 ThreadLocalMap 中 key 为 null 的value。避免内存泄露；

---

### 59. 

---

### 60. 

---


### 1. 

---

### 2. 

---

### 3. 

---

### 4. 

---

### 5. 

---

### 6. 

---

### 7. 

---

### 8. 

---

### 9. 

---

### 0. 

---

