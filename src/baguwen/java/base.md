---
title: Java 基础
icon: file
author: Cheney
date: 2024-04-10
isOriginal: true
category: Java
order: 1
---

<!-- <div>
    <h3>1. Java 语言有哪些特点？</h3>
    <div style="border-radius:20px;background-color:#F0FFF0;padding:1px">
        
    </div>
</div> -->

### 1. Java 语言有哪些特点？

- 面向对象（封装，继承，多态）；
- 平台无关性（ Java 虚拟机实现平台无关性）；
- 编译与解释并存；支持多线程；

---

### 2. JVM vs JDK vs JRE 三者的区别？
- JVM：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现。 
- JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。 
- JDK（Java Development Kit）,包含JRE、编译器javac、javadoc等工具。提供给开发者使用。 
> [!tip]
> Tips: JDK = JRE + 开发工具 ；JRE = JVM + Java SE API 类库 ；

---

### 3. 什么是字节码？字节码的好处是？
+ 被JVM解释执行的.class文件，即.java文件编译后的文件。
+ 字节码的好处是：实现了一次编译，到处运行，屏蔽了底层操作系统的差异，实现了跨平台。
> [!tip]
> 代码执行的过程可以理解为：.java源码 ---编译---> .class字节码 ---解释执行---> 机器码 ，解释执行的速度比编译执行（C++编译执行）慢，因此对于一些经常被调用的代码JVM使用JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用，来提高执行效率。

---

### 4. 为什么说 Java 语言“编译与解释并存”？
+ .java 源代码先编译成 .class 字节码，而字节码是通过 JVM 解释成二进制机器码执行的，这种方式既保留了解释执行的特点，又提高了执行效率。
+ 部分高频执行的热代码会使用 JIT 编译器将字节码编译成机器码，提高执行效率。

---

### 5. 基本移位运算符了解码？
-  `<<` : 左移运算符，向左移若干位，高位丢弃，低位补零。x << 1,相当于 x 乘以 2(不溢出的情况下)。 
-  `>>` : 忽略符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x >> 1,相当于 x 除以 2。 
-  `>>>` : 带符号右移，例如 -2>>>1 答案不是 -1 而是 2147483647，空位都以 0 补齐。 

---

### 6. 基本类型和包装类型的区别？
- **占用空间**： 基本类型占用空间小，包装类型占用空间大。
- **默认值**： 基本类型有默认值，包装类型默认值为 null。
- **存储方式**： 包装类型存储在堆中，基本数据类型如果是成员变量则存储在堆中，如果是局部变量则存储在栈中。如果使用static修饰的基本数据类型存储在方法区中。
- **比较方式**： 使用 == 号基本类型比较的是值，包装类型比较的是地址。对于包装类型使用equals方法比较的是值。

---

### 7. 为什么浮点数运算的时候会有精度丢失的风险？
因为计算机是二进制机器，二机制机器天然擅长表达整数数据类型，如果需要表达浮点数那么需要更长的位数来表示，而表示一个浮点数的数据类型的位数是有限的，而一个小数可以是无限的，因此需要进行截断从而导致精度丢失。因此，一些浮点数没有办法用二进制精确表示，就比如说十进制下的 0.2 就没办法精确转换成二进制小数：0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止。

---

### 8. 如何解决浮点数运算的精度丢失问题？

- 如果非要使用基本数据类型例如double，那么需要使用指定一个误差范围，然后在比较的时候，两个数的差值小于这个误差范围，就认为这两个数相等。
- 建议直接使用BigDecimal类并，然后讲一下BigDecimal类原理；BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。BigDecimal 的实现利用到了 BigInteger （用来操作大整数）, 所不同的是 BigDecimal 加入了小数位的概念。BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。BigDecimal类型的变量比较大小使用compareTo()方法，equals() 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 compareTo()方法比较的时候会忽略精度。
- 在一些情景下也可以使用long或者double类型，但是需要注意下面精度问题。对于浮点数而言，基本数据类型不能使用==比较大小，包装类型不能使用equals()比较大小，而是指定一个误差范围；或者直接使用BigDecimal。

---

### 9. 超过Long类型的数据如何存储？
使用BigInteget存储；BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。

---

### 10. 重载与重写区别？
- 重写：一般使用@Override修饰重写的方法，发生在继承父类的子类中，如果子类重写了父类方法则子类真实调用是子类的实现，如果子类未实现则调用父类方法，要求方法名、参数列表、返回值相同。
- 重载：同一个类中，方法名相同，参数列表不同（包括参数不同、参数顺序不同，参数个数不同）则视为重载，对返回值没有强制要求，可以相同也可以不同。重载只能看参数列表是否不同，不能看返回值，只有发生了重载才能返回值不同！
---

### 11. 介绍Java的基本数据类型及其大小？
记忆顺序： byte、short、int、long、float、double、char、boolean。 所占字节大小分别是 1、2、4、8、4、8、2、1 个字节。
> [!tip]
> Tips: byte 是1字节，一直到long 8 字节不断翻倍。然后记住float 和 int 都是4字节，double 和 long 都是8字节。char 是2字节，boolean 不到1字节，一位即可。1字节等于8位，所以 int 有32位能够表达的数据范围是 -2^31 ~ 2^31-1 。

---

### 12. 什么是自动装箱和拆箱？
Java的数据基本数据类型对应的对象类型叫做基本数据类型包装类，例如int的包装类是Integer，long的包装类型是Long，char的包装类型是Character。在进行互相转换的时候，Java提供了非常简单的机制，这种机制叫做自动装箱与拆箱。如下：
```java
Integer in = 10; //装箱:装箱其实就是调用了包装类的Integer.valueOf(10)方法
int n = in; //拆箱:拆箱其实就是调用了 in.intValue()方法。
```

> [!note] 
> 为什么要有包装类型？这就是基本数据类型与包装类型的区别，参考第6问，另外注意在拆箱时可能会出现空指针异常，如果上述代码中 in 为 null 的话，那么 in.intValue() 其实调用的是null，会抛出空指针异常。往往面试中也喜欢问这点，所以数据库查询时不要用基本数据类型来接，如果没查到数据返回的就是null，而要用包装对象来接返回值。

---

### 13. 包装类型的常量池化技术|自动装箱的缓存机制?
缓存机制只针对包装类型，不包括基本数据类型，调用Integer.valueOf(10)装箱(自动装箱)的时候，可以避免频繁地new Integer(10)来创建对象，对小范围内的包装类型是直接从缓存中获取。Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据， Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False 。两种浮点数类型的包装类 Float,Double 并没有实现常量池技术 。因此，使用包装类型的常量池中的对象都是相同的对象。

``` java
Integer i1 = 40; //自动装箱，调用valueOf(40)，是从缓存中获取对象
Integer i2 = new Integer(40); // 直接在堆内存中创建一个新的Integer对象
System.out.println(i1==i2); // false，==比较的是对象地址，两个对象肯定不是同一个，一个是缓存中的，另外一个是新创建的
```
---

### 14. 为什么需要包装类型？
- 接住Null值，基本数据类型无法接住Null值，而包装类型可以。
- 泛型，泛型只能接受引用类型，不能是基本数据类型，所以需要包装类型。例如集合，集合中不能存放基本数据类型，只能存放包装类型。
- 基本数据类型不是引用类型，凡是引用类型能完成的功能基本数据类型都不能，例如对象锁。
:::details
总而言之，以上理由都是基本数据类型与引用类型的区别。包装类型初始值可以是null值，基本数据类型初始值有默认值且不能为null，这在SQL查询返回整型时候可能会返回null，而用基本数据类型来接返回值可能在会发送空指针异常(自动装箱时调用null.valueof())。例如ArrayList，HashSet等数据结果都是接受的是包装类型，这是因为包装类型都是Object的子类，所以才能使用泛型。
:::

---

### 15. Java 方法是值传递还是引用传递？
- Java任何时候都是值传递，当传递对象时，传递的是对象的引用的值，也就是地址。
- 当传递基本数据类型时，传递的是基本数据类型的值。
> [!important]
> swap(int a,int b) 交换两个基本数据类型的值，是不行的，因为传递的是值，不是引用。swap(Integer a,Integer b) 交换两个包装类型的值，是可以的，因为传递的是引用的值，也就是地址。无论int还是Integer，都是值传递，只不过Integer是引用类型，传递的是引用的值，也就是地址。


---

### 16. 成员变量与局部变量的区别？
- 定义的位置不同：成员变量在局部代码块之外；局部变量在局部代码块中； 
- 内存中的位置不同：如果变量是引用类型那么都是存放在堆内存上的，下面讨论的都是基本数据类型，成员变量可以被static修饰，属于类的存放在运行时常量池中（堆中），不被static修饰的成员变量存储在堆中；局部变量不能被static修饰存储在栈内存的局部变量表中。
- 生命周期不同：成员变量是对象（类）的一部分，随着对象创建（类）而创建销毁而销毁；局部变量随着方法调用结束而结束； 
- 默认值不同：一般讨论基本数据类型和包装类对象，成员变量有默认值，局部变量需要赋值；数组局部变量也有默认值！

---

### 17. 静态变量static修饰？
它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建了多个对象，这样可以节省内存。通常情况下，静态变量会被 final 关键字修饰成为常量。

---

### 18. 静态方法为什么不能调用非静态成员？
静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

---

### 19. 面向对象三大特征？
- 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。
- 继承：子类继承父类的属性和方法。
- 多态：父类引用指向子类对象，Animal dog = new Dog()。

---

### 20. 接口和抽象类有什么共同点和区别？
**共同点** ： 
- 都不能被实例化。 
- 都可以包含抽象方法。 
- 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。 

**区别** ： 
- 接口主要用于对类的**行为进行约束**，你实现了某个接口就具有了对应的行为。抽象类主要**用于代码复用，强调的是所属关系**。 
- 一个类只能继承一个类，但是可以实现多个接口。 
- 接口中的成员变量只能是 public static final 类型（常量）的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

---

### 21. Object对象为什么要有 HashCode 方法？
**HashCode的作用:** 将对象的内存地址映射得到哈希码。在HashSet、HashMap中会先计算对象的 hashCode值来判断对象加入的位置，然后判断是否有相同的HashCode重复出现，如果没有则加入操作成功。否则使用equals来判断hashCode相等的对象属性是否真的相同，如果不同就会重新散列到其他位置，这样我们就大大减少了equals的次数，相应就大大提高了执行速度。与问题“为什么 JDK 还要同时提供HashCode和equals这两个方法呢？”同答案！

---

### 22. 为什么重写equals()方法必须重写hashCode()方法？
先进行hashCode()判断两个对象是否相同，如果hashCode判断不同则一定不同。如果hashCode判断两个对象的哈希值相同则两个对象也不一定是相等的（考虑哈希碰撞），因此这时才需要使用equals()来判断两个对象的属性值是否相等。另外，有了hashCode可以大大减少equals()判断的次数，提高效率。下面两点很关键：
- equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。
- 两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。

---


### 23. String.intern() 方法有什么作用？
前面第13问提到过整数的基本数据类型包装类型对象有缓存，那么其实字符串也有缓存池，通过关键字String.intern()方法将字符串的引用放到字符串常量池中，字符串常量池保存被池化的字符串的引用而非对象本身，对象还是在堆上。String.intern() 是一个字符串池化的方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况： 
- 如果字符串常量池中保存了对应的字符串对象引用，就直接返回该引用。 
- 如果字符串常量池中没有保存了对应的字符串对象引用，它会将当前字符串对象引用添加到常量池，并返回对应的引用。

---


### 24. 字符串常量池的作用？

- 提升性能，直接引用不重新创建字符串对象
- 避免字符串重复创建浪费内存空间

---

### 25. String 类型本质？
String 的本质其实是一个 char 类型的数组（JDK1.8是如此，JDK17是字节数组），通过final修饰能够保证指向该数组地址的引用对象不能修改，但是数组本身内的值可以被修改。 所以这里还加了另一个关键字private，防止从外部进行修改 。因此String 是不可变的了，但是也可以通过暴力反射来修改数组本身。

---

### 26. instanceof 关键字？
Java中的一个双目运算符 ，用来判断一个对象是否为一个类的实例 。

---

### 27. HashSet如何检查重复？
对象加入HashSet，首先计算hashCode值来判断加入的位置，如果没有冲突加入，如果有冲突调用equals方法来检查两个对象是否真的相同。如果不同则散列到其他位置加入，相同则不加入。这样就大大减少equals的次数，提高了执行效率！

---

### 28. String、StringBuffer 和 StringBuilder 的区别是什么？
String是被final+private修饰是不可修改的对象，如果使用+号连接两个String 底层是创建了StringBuilder对象然后调用了append方法追加字符串，最后toString为String对象；只有StringBuffer线程安全；其他两个非线程安全；因此，频繁地修改字符串应该使用StringBuilder，避免String频繁创建与销毁StringBuilder对象导致效率低下。

---

### 29. 泛型和通配符了解吗？(这个问题我讲的不太好，建议自己学习一下)
**泛型T**
编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型 ，泛型一般有三种使用方式:泛型类、泛型属性、泛型方法 。例如可以在以下地方使用泛型：
- 自定义接口通用返回结果
- 构建通用的集合工具类（参考 Collections 中的 sort, binarySearch 方法）
```java
// 上边界泛型限制类型为 Person 的子类
<T extends Person>
// 下边界泛型限制类型为 Manager 的父类
<T super Manager>
```

**通配符?**
泛型和通配符最根本的区别就是Java编译器会把泛型【T】推断成具体类型，而把通配符【?】推断成未知类型。Java编辑器只能操作具体类型，不能操作未知类型，如果有对参数做修改的操作就必须要使用泛型，如果仅仅是查看就可以使用通配符。
```java
// 如果我们想让list中放入任意的数据类型，可以是List<String>或者List<Long>等
List<?> list = new ArrayList<>();
// 上边界通配符限制类型为 Person 的子类
<? extends Person>
// 下边界通配符限制类型为 Manager 的父类
<? super Manager>
```
**通配符 ？和常用的泛型 T 之间有什么区别？**
- T 可以用于声明变量或常量而 ? 不行。
- T 一般用于声明泛型类或方法，通配符 ? 一般用于泛型方法的调用代码和形参。
- T 在编译期会被擦除为限定类型或 Object，通配符用于捕获具体类型。


---

### 30. Java的四种引用了解吗？
强软弱虚：
- 强引用：在程序内存不足（OOM）的时候也不会被回收。
- 软引用：软引用在程序内存不足时，会被回收。
- 弱引用：弱引用就是只要JVM垃圾回收器发现了它，就会将之回收。
- 虚引用：虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中 ，其它引用是被JVM回收后才被传入 ReferenceQueue 中的 ，所以虚引用大多被用于引用销毁前的处理工作。

---

### 31. Java创建对象有几种方式？
- new
- 反射：使用 newInstance()
- clone
- 反序列化：ObjectInputStream 类的 readObject() 方法 。

---

### 32. 避免hash冲突的方法？
- 拉链法
- 开放地址法
- 再哈希

---

### 33. 深拷贝和浅拷贝的区别是什么？
- 引用拷贝：不同引用指向同一个对象；
- 浅拷贝：重新创建一个新的对象，新对象中的引用属性和老对象中的引用指向的对象相同，即外壳不一样，内部对象一样。
- 深拷贝：完全创建一个新的对象，内部的对象也是新的对象。

---

### 34. final有哪些用法？
- 被final修饰的类不可以被继承。
- 被final修饰的方法不可以被重写,JVM会尝试将其内联,以提高运行效率。
- 被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变。
- 被final修饰的常量,在编译阶段会存入常量池中。

---

### 35. static都有哪些用法？
- 静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享。
- static也用于静态块，初次被加载的时候执行且仅会被执行一次(单例模型饿汉模式的一种实现)，多用于初始化操作，类中可以有多个static块。
- 静态导包 ，导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名。

---

### 36. a=a+b与a+=b有什么区别吗？
以下讨论的都是基于 a+b 的值小于 a 类型的最大值：
- 假设 a 和 b 的类型一样 或者 b的精度小于a，则没什么区别。
- 假设 b 的精度大于 a，则 a+=b 会隐式自动进行类型转换，不报错。而 a = a+b 要求左右两边类型一致从而报错，想不报错就得使用强制类型转换成和a一致的数据类型。
```java
int a = 10;
long b = 10;
a = a + b; // 报错，编译不通过
a += b     // 等价于  a = a + (int)b; 不报错
```
---

### 37. try catch finally，try里有return，finally还执行么？
执行，并且finally的执行早于try里面的return ,当try和catch中有return时，finally仍然会执行。finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的。finally中如果有 return 则返回的是finally中的结果。

---

### 38. Java的异常类了解吗？
在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类Error和Exception，而Exception包括运行时异常(RuntimeException)和被检查异常，运行时异常也称为非受检异常。

- 运行时异常：RuntimeException及其子类都被称为运行时异常 ，编译器不会检查它，例如除零ArithmeticException异常 ，数组越界时产生的IndexOutOfBoundsException异常 ，fail-fast机制产生的ConcurrentModificationException异常。NullPointerException（空指针异常）
- 受检查异常：Exception类本身，以及Exception的子类中除了"运行时异常"之外的其它子类都属于被检查异常。 Java编译器会检查它 ，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译 。IOException ，FileNotFoundException ，SQLException 。
- Error：和运行时异常一样，编译器也不会对错误进行检查 ，当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError，OutOfMemoryError、StackOverflowError、ThreadDeath 就属于错误。
---

### 39. Throwable 类常用方法有哪些？
- String getMessage(): 返回异常发生时的简要描述
- String toString(): 返回异常发生时的详细信息
- void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息

---

### 40. OOM你遇到过哪些情况，SOF你遇到过哪些情况？
- OutOfMemoryError异常 ，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。虚拟机栈和本地方法栈溢出：如果方法递归调用导致线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果虚拟机设置栈空间不足可自动扩展，则在扩展栈时如果系统内存也不足无法申请到足够的内存空间，则抛出OutOfMemoryError异常。方法区溢出：方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置，堆内存大量创建对象也会导致OOM。
- SOF（堆栈溢出StackOverflow）：StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误 ，递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大 。

---

### 41. 简述协程、线程、程序、进程的基本概念以及他们之间关系是什么?
- 程序：是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
- 进程：是程序的一次执行过程，是系统运行程序的基本单位 。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序 。
- 线程：与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。
- 协程：一个线程可以有多个协程，协程只在用户态进行切换，不涉及到内核态，协程比线程又要更加节省开销。
- 进程是操作系统资源分配的最小单位，线程是CPU调度的最小单位。
---

### 42. 序列化和反序列化知道吗？
如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。尤其在微服务架构中的远程调用中常见，比较常用的序列化工具有 Hessian2 和 Protobuf。
- 序列化： 将数据结构或对象转换成二进制字节流的过程。
- 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。

---

### 43. Java 序列化中如果有些字段不想进行序列化，怎么办？
对于不想进行序列化的变量，使用 transient 关键字修饰 ，transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；一般使用Hessian、protobuf等协议而不用JDK自带的。

- 当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。
- transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是0。
- static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。
---

### 44. java反射的作用与原理知道吗？
- 反射机制是在运行时，对于任意一个类，只要给定类的名字 ，都能够知道这个类的所有属性和方法等信息。并可以实例化它并调用其方法。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。
- 哪里会用到反射机制？ jdbc就是典型的反射 ，在Spring框架中代理的实现等都使用了反射。
- 反射获取Class对象的方式有哪些？ 有4中方法： 1）Class.forName(“类的路径”)； 2）类名.class 3）对象名.getClass() 4）基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象 。
- 反射的优缺点：优点：1）能够运行时动态获取类的实例，提高灵活性； 2）与动态编译结合。 缺点： 1）使用反射性能较低，需要解析字节码，将内存中的对象进行解析。 解决方案： 1、通过setAccessible(true)关闭JDK的安全检查来提升反射速度；相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性)。
---

### 45. 注解的原理了解吗？
可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。注解本质是一个继承了 Annotation 的特殊接口。这个类啥都不用实现，就仅仅是标记一下。那如何通过注解执行业务逻辑呢？一般需要在拦截器或者过滤器中进行判断注解类型，然后执行对应的业务逻辑。注解的解析方法有哪几种？注解只有被解析之后才会生效，常见的解析方法有两种：

- 编译期直接扫描 ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- 运行期通过反射处理 ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。

---

### 46. Object 有哪些常用方法？大致说一下每个方法的含义？
- clone方法：克隆方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出CloneNotSupportedException 异常，深拷贝也需要实现 Cloneable，同时其成员变量为引用类型的也需要实现 Cloneable，然后重写 clone 方法。
- equals方法：一般 equals 和 == 是不一样的，但是在 Object 中两者是一样的。子类一般都要重写这个方法。
- hashCode 方法 ：该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法，equals相等则hashCode必须相等，hashCode相等还要判断值是否相等。例如 "Aa"和"BB"的哈希值相等。
- wait 方法 ：配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait() 方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。调用该方法后当前线程进入睡眠状态，直到以下事件发生。1. 其他线程调用了该对象的 notify 方法；2. 其他线程调用了该对象的 notifyAll 方法；3. 其他线程调用了 interrupt 中断该线程；4. 时间间隔到了。此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。
- notify 方法 ：配合 synchronized 使用，该方法唤醒在该对象上等待队列中的某个线程（同步队列中的线程是给抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。
- notifyAll 方法 ：配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程。

---

### 47. 说说什么是 fail-fast（快速失败异常）？
当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件，某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件。

---

### 48. 说说Hashtable 与 HashMap 的区别？
- Hashtable 中大部分线程安全的方法都是 synchronized 字段修饰的，是线程安全的，HashMap 是非线程安全的。
- Hashtable 的 key 不能为 null，value 也不能为 null 。HashMap 的 key 和 value 都可以为 null。
- Hashtable 直接使用对象的 hash 值 ，HashMap 为了提高计算效率，将哈希表的大小固定为了 2 的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。
- 如果需要线程安全高并发的话，推荐使用 ConcurrentHashMap 代替 Hashtable。

---

### 49. HashMap 中的 key 我们可以使用任何类作为 key 吗？
如果使用其他类的对象作为key（例如Student的对象），如果直接用的话则key是引用地址（两次new出的值相等的对象地址不一样因此无法使用），如果想让其值相等的对象也能够从HashMap中取值的话，需要重写equals和hashCode方法，让hashCode返回属性的hashCode，equals判断属性值是否相等。自定义 key 类的最佳实践是使之为不可变的。


---

### 50. HashMap的长度为什么是2的N次方？
为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。 我们一般采用模来映射，取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&）操作（也就是说hash % length == hash &(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进制位操作 & ，相对于 % 能够提高运算效率。

---

### 51. HashMap 与 ConcurrentHashMap 的异同？
- 都是 key-value 形式的存储数据
- HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的
- HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8 之后是数组 + 链表 + 红黑树。当链表中元素个数达到 8 的时候且桶数量超过64，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；
- HashMap 初始数组大小为 16（默认），当出现扩容的时候（数量达到装载因子的比例），以 2* 数组大小的方式进行扩容；
- ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment + HashEntry，Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8 之后，抛弃Segmant，采用 Node + CAS + Synchronized+链表+红黑树（Node变成treeNode），来保证并发安全进行实现。
---

### 52. JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？
- 线程安全实现方式：JDK 1.7 采用 Segment 分段锁来保证安全， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。
- Hash 碰撞解决方法 : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。
- 并发度：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。

---

### 53. 红黑树性质了解吗？
- 每个节点只能是黑色或者红色，根节点和叶子节点都是黑色
- 红色节点的孩子节点是黑色的
- 从一个节点到该节点的后代叶子节点的路径上黑色节点数目相同。

---

### 54. Java IO 流了解吗？
IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

---

### 55. I/O 流为什么要分为字节流和字符流呢？
- 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；对于文本数据使用字符流会更快，而对于视频音频等非文本数据可以使用字节流。
- 如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。因此，I/O 流就干脆提供了一个字符流接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

---

### 56. 字节缓冲流知道吗？
IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。字节缓冲流这里采用了装饰器模式来增强 InputStream 和OutputStream子类对象的功能。举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能。相反是BufferedOutputStream。

---

### 57. SPI与API的区别？
- 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。
- 当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。

---

### 58. Java中用过哪些容器或者数据结构，哪些是线程安全的？
一般我们日常写算法使用的都是非线程安全的类，那么在多线程环境下一般会使用JUC中的同步集合。如下：
非线程安全的容器：
- ArrayList：数组
- LinkedList：双向链表、队列、栈(线程安全可以用Stack)
- HashMap：哈希表
- HashSet：哈希集合

线程安全的容器：
- CopyOnWriteArrayList：线程安全的ArrayList
- CopyOnWriteArraySet：线程安全的HashSet
- ConcurrentHashMap：线程安全的HashMap
- BlockingQueue：线程安全的阻塞队列

另外，JUC中还有一些安全的同步容器：CountDownLatch、CyclicBarrier、Semaphore；对于基本数据类型，也有线程安全的类 AtomicInteger、AtomicLong、AtomicBoolean 等。AtomicReference 和其他原子引用类：用于原子地更新对象引用。

---

### 59. Java 中父类和子类的静态代码块、非静态代码块、构造方法的执行顺序是怎样的？
1. 父类的静态代码块
2. 子类的静态代码块（按照继承层次由上到下依次执行）
3. 父类的非静态代码块
4. 父类的构造方法
5. 子类的非静态代码块（按照继承层次由上到下依次执行）
6. 子类的构造方法
---

### 60. 什么是守护线程？想·
Java 把线程分成两类：用户线程（User Thread） + 守护线程（Daemon Thread）

守护线程的使用有以下要点：

- 当程序中所有的用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出（也就是说只要存在一个用户线程在允许，守护线程就不会结束）
- 守护线程必须在 start 启动前通过 setDaemon() 方法将状态设置为 true，启动后就不能进行设置，否则报 InterruptedException 异常
- 守护线程存在被 JVM 强制终止的风险，所以在守护线程中尽量不去访问系统资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失，所以守护线程适合执行无需完整执行的后台任务。
- 守护线程中创建的线程也是守护线程

JVM 进程中的 GC 线程就是一个守护线程，这样设计目的很明确，当你所有的程序都执行完毕了，留着这个 GC 线程就没有任何意义了。反过来可以设想，如果把 GC 线程设计成非守护线程，当你明确你的程序都执行完毕了，但是就是不自动退出岂不是很奇怪？

---

