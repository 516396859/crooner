---
title: Java 基础
icon: file
author: Cheney
date: 2024-04-10
isOriginal: true
category: Java
---

<!-- <div>
    <h3>1. Java 语言有哪些特点？</h3>
    <div style="border-radius:20px;background-color:#F0FFF0;padding:1px">
        
    </div>
</div> -->

### 1. Java 语言有哪些特点？

- 面向对象（封装，继承，多态）；
- 平台无关性（ Java 虚拟机实现平台无关性）；
- 编译与解释并存；支持多线程；


### 2. JVM vs JDK vs JRE 三者的区别？
- JVM：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现。 
- JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。 
- JDK（Java Development Kit）,包含JRE、编译器javac、javadoc等工具。提供给开发者使用。 
> [!tip]
> Tips: JDK = JRE + 开发工具 ；JRE = JVM + Java SE API 类库 ；


### 3. 什么是字节码？字节码的好处是？
+ 被JVM解释执行的.class文件，即.java文件编译后的文件。
+ 字节码的好处是：实现了一次编译，到处运行，屏蔽了底层操作系统的差异，实现了跨平台。
> [!tip]
> 代码执行的过程可以理解为：.java源码 ---编译---> .class字节码 ---解释执行---> 机器码 ，解释执行的速度比编译执行（C++编译执行）慢，因此对于一些经常被调用的代码JVM使用JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用，来提高执行效率。


### 4. 为什么说 Java 语言“编译与解释并存”？
+ .java 源代码先编译成 .class 字节码，而字节码是通过 JVM 解释成二进制机器码执行的，这种方式既保留了解释执行的特点，又提高了执行效率。
+ 部分高频执行的热代码会使用 JIT 编译器将字节码编译成机器码，提高执行效率。


### 5. 基本移位运算符了解码？
-  `<<` : 左移运算符，向左移若干位，高位丢弃，低位补零。x << 1,相当于 x 乘以 2(不溢出的情况下)。 
-  `>>` : 忽略符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x >> 1,相当于 x 除以 2。 
-  `>>>` : 带符号右移，例如 -2>>>1 答案不是 -1 而是 2147483647，空位都以 0 补齐。 


### 6. 基本类型和包装类型的区别？
- **占用空间**： 基本类型占用空间小，包装类型占用空间大。
- **默认值**： 基本类型有默认值，包装类型默认值为 null。
- **存储方式**： 包装类型存储在堆中，基本数据类型如果是成员变量则存储在堆中，如果是局部变量则存储在栈中。如果使用static修饰的基本数据类型存储在方法区中。
- **比较方式**： 使用 == 号基本类型比较的是值，包装类型比较的是地址。对于包装类型使用equals方法比较的是值。


### 7. 为什么浮点数运算的时候会有精度丢失的风险？
因为计算机是二进制机器，二机制机器天然擅长表达整数数据类型，如果需要表达浮点数那么需要更长的位数来表示，而表示一个浮点数的数据类型的位数是有限的，而一个小数可以是无限的，因此需要进行截断从而导致精度丢失。因此，一些浮点数没有办法用二进制精确表示，就比如说十进制下的 0.2 就没办法精确转换成二进制小数：0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止。

### 8. 如何解决浮点数运算的精度丢失问题？
使用 BigDecimal 类进行运算，BigDecimal 类提供了精确的数学运算，可以解决浮点数运算的精度丢失问题。BigDecimal 的实现利用到了 BigInteger （用来操作大整数）, 所不同的是 BigDecimal 加入了小数位的概念。BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。

- BigDecimal类型的变量比较大小使用compareTo()方法，equals() 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 compareTo() 方法比较的时候会忽略精度。 
- 在一些情景下也可以使用long或者double类型，但是需要注意下面精度问题。对于浮点数而言，基本数据类型不能使用==比较大小，包装类型不能使用equals()比较大小，而是指定一个误差范围；或者直接使用BigDecimal。


### 9. 超过Long类型的数据如何存储？
使用BigInteget存储；BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。

### 10. 

### 11.

### 12.


### 13.


### 14.


### 15.


### 16.



### 17.



### 18.



### 19.



### 20.



### 21.



### 22.