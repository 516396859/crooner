---
title: 分布式情景
icon: file
author: Cheney
date: 2024-05-06
isOriginal: true
category: Java
order: 2
---
 

### 1. 分布式ID
这个问题主要需要考虑两个方面：安全性和严格递增：
- 如果不考虑安全性而考虑自增的话：那么使用redis的自增产生分布式ID，可以使用Cluster集群保证高可用和高并发，一秒十几万二十几万个很容易实现，但是容易被猜测到一些信息-业务量；
- 如果考虑安全性和不考虑自增的话：预先分片：采用十台机子每个机子维护一段范围的ID，优点是速度飞快；
- 如果既要安全性又要自增的话：那么选择雪花算法，前面41位是时间戳，中间10位是机器ID，后面12位是自增序号。可以保证后面来的需要一定比前面来的序号大，但是时间相同无法保证顺序。（64位）

单机的Redis无法集群，但是雪花算法可以集群，每个节点安装相同的算法算出来的ID基本上都是一样的；UUID 有好几个版本，一般是通过时间戳和MAC地址生成，无序；缺点是32个字符串（128位）消耗存储空间很大；以MAC地址生成的UUID几乎不会重复，因为MAC地址全球唯一，但是同一台机子在极端时间申请UUID可能出现重复，最大问题就是无序、存储空间大、MAC地址泄露问题。其他厂商如美团的Leaf 和 百度的 UIDGenerator 对雪花算法进行了改进；

---

### 2. 分布式Session
- 一致性Hash，根据请求路径映射到某台服务器，一旦确定后面都是访问该台服务器；如果这台服务器宕机或者增删了服务器，那么可能会出现问题。
- Session缓存共享：利用redis缓存Session，这也是Spring Session中的一个解决方案。
- JWT的token机制：通过电子签名的方式将用户数据存放在用户端，用户访问时带上token即可，缺点是无法控制客户端的token立即失效，需要等超时过期。

---

### 3. 分布式锁
- Redis实现分布式锁：基于setnx实现唯一键值，如果已存在返回false；使用expire设置过期时间。缺点是不可重入，且不可用超时中断；
- Redission分布式锁：支持可重入、超时中断，实现了连锁；当redis集群后无需考虑主从一致性锁的问题，连锁对所有节点都加锁保证锁同步。

---

### 4. 分布式幂等性
- 建立关键字段的唯一性，例如商品ID和用户ID建立联合唯一性索引，保证只有一个唯一记录。
- 幂等表：要求前端每次回话都生成一个请求ID附加在head中，保证一定时间内唯一即可，在Nginx网关中检查这个请求ID是否已经存在，如已经存在则表示是重复请求不响应业务，否则响应业务。redis requestID作为key，处理结果作为value。可以伪造requestID，因此需要使用业务相关的字段，例如用户ID+请求路径作为requestID。

---



### 5. 分布式事务
- 事务的操作不是在一个节点上，需要保证事务的AICD特性；例如秒杀项目中将订单业务和库存业务进行了分离—分库在不同的服务器上；那么减少库存的同时需要更新订单信息，而这两者不在一个服务器上，因此涉及分布式事务；
- 解决方案：消息中间件，当扣减库存成功后向MQ发送一个消息，而订单系统订阅这条消息之后完成下单操作；MQ的消息处理模式：简单模式，work模式，广播模式fanout，发布订阅模式（主题模式，定向模式）; 分布式事务的Redis和Mysql数据库同时扣减；

---

### 6. 分布式限流
- 固定窗口计数器：比如60秒一个区间，这个区间限制1000个访问，超过拒绝服务；
- 滑动窗口计数器：这个区间的粒度更加细，也就是说刚才固定的区间如果新的区间开始1秒就被访问了1000次，后面59秒就无法访问了。那么如果是滑动的话，意味着不会让这个区间在开始1秒就被1000次访问完了，而是它会计算前面的滑动窗口里面的，可能新的这个区间开始了只让访问500次。
- 漏桶限流：请求就像源源不断的水流流进桶里，桶底有个洞以一定的速率流出，这个速率就是服务提供方以一定的速率从桶里取出请求执行。缺点是：当突发大量请求会造成桶中有大量请求等候，即使服务器依旧能处理大量请求；
- 令牌桶限流：以一定速率源源不断往桶里放发令牌，拿到令牌的请求可以被处理。时间越久桶里的令牌越多，没有令牌就拒绝服务。令牌上限是服务器的最大处理请求数量，令牌的好处是可以处理突发流量；
- 在Nginx中可以配置漏桶限流和令牌桶限流算法，也可以使用Redis+Lua实现限流算法。

---

### 7. 负载均衡算法
- 轮询，适合每台服务器性能差不多的情景
- 加权轮询，权值为6则需要访问6次才轮询到下一个服务器；
- 最少连接，将请求发送给当前连接数最少的服务器上；
- 随机算法，随机地发送请求到服务器上；

### 8. 分布式脑裂问题
脑裂指一个集群由于网络的故障，被分为至少两个彼此无法通信的单独集群，此时如果两个集群都各自工作，则可能会产生严重的数据冲突和错误。一般的设计思路是，当集群判断发生了脑裂问题时，规模较小的集群就“自杀”或者拒绝服务。

**如何防止分布式脑裂问题？**
- 当出现两个节点有分歧时，向第三方仲裁（锁服务）
- 当不确定某个节点状态时，通过fencing把对方干掉；


### 9. 分布式与集群的区别
- 分布式：一个大业务分为多个微服务子业务部署在不同服务器；
- 集群：一个大业务部署在多个服务器提供服务，例如redis集群；

### 10. 如何设计高并发系统
-  html 页面尽量静态化，且在Nginx浏览器本地进行缓存，秒杀按钮及时设为不可用； 
- 系统拆分：将系统拆解为多个微服务，每个服务对应一个数据库。
- 使用缓存：读高并发，使用redis缓存替代mysql缓存，减轻mysql读压力；
- 消息队列：写高并发，使用MQ削峰填谷，减轻MySQL写压力；
- 读写分离：大部分时候数据库可能也是读多写少，可以将数据库集群，一主多从；
- 分库分表：不同业务建立单独数据库；

### 11. 1000个任务，分给10个人做，你怎么分配，先在纸上写个最简单的版本，然后优化
- 使用队列，一个队列，十个消费者
- 十个队列，十个消费者

### 12. 100万个数，输出从小到大？
先划分成多个小文件，送进内存排序，然后再采用多路归并排序。

### 13. 保证发送消息的有序性，消息处理的有序性？
根据业务的不同分为不同的消息队列，将公用消息队列进行细分；需要保持先后顺序的消息放到同一个消息队列中；然后使用线程池消费的时候使用分布式锁和本地锁保证同时只有一条线程去消费一个队列（Queue）上的数据。